NIO
NIO分为三个部分：
	channel，缓冲区，selector
	传统的IO流是基于字节流和字符流进行操作的，而nio是基于channel和缓冲区进行操作的，数据总是从channel读取到缓冲区，或者从缓冲区写到channel。selector是监听多个通道的事件，因此单个线程可以监听多个数据通道。
	
Channel
	跟流是差不多一个级别的。只不过流是单向的，channel是双向的，可以读也可以写。主要实现有filechannel，DataGramChannel，SocketChannel，ServerSocketChannel。
	
Buffer
	Buffer有ByteBuffer...(八大基本数据类型)
	
Selector
	Selector运行单线程处理多个Channel
	
NIO和传统IO最大的区别
	IO是面向流的，NIO是面向缓冲区的。
	IO读数据是每次从流中读一个字节或者多个字节，直到流读完所有字节，它们没有缓冲到任何地方，它不能前后移动流中的数据，如果需要前后移动从流中读取的数据，需要先缓存到一个地方。
	NIO它是将数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区前后移动，但是还需要检查是否该缓存区中包含您需要处理的数据，需确保更多的数据读入缓冲区时，不要覆盖缓冲区未处理的数据。
	
	io流是堵塞的，所以调用read或者write方法时，该线程堵塞，期间不能干任何事情。
	NIO的非堵塞模式，使一个线程从某通道发出请求读取数据，但是它仅能得到目前可用的数据，如果目前没有可用数据时，就什么都不会获取，而不是保持线程阻塞，该线程可以干别的事情。
	非阻塞写也是一样，一个线程请求写入一些数据到某个通道，不需要等待它完全写入，这个线程也可以干别的事情。所以一个单独的线程可以管理多个输入输出通道。

情景：
	客户端每隔几秒发送一个数据给服务端，服务端收到后就打印
	每一个新的连接都创建一个线程用字节流去读数据。
分析：
	IO编程模型在客户端少的情况下运行良好，但是对客户端比较多的业务来说，
	服务端可能需要支撑成千上万的连接，IO编程模型不适合。
原因：
	传统的IO模型中，每一个连接创建成功后需要一个线程去维护，每一个线程又包含一个while死循环，那么一个万个连接对应一万个线程，一万个死循环。
	1.线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态是非常严重的资源浪费。
	2.线程切换效率低下，单机cpu核数固定，线程爆炸后操作系统频繁进行线程切换，性能急剧下降。
	3.IO编程中，数据读写以字节流为单位效率不高。
	
解决：
	nio模型中，把多个死循环变成一个死循环，这个死循环由一个线程控制。
原理：
	NIO模型中seleor的作用，一条连接进来后，先不创建while死循环去监听是否有数据可读，而是直接把这条连接注册到selector上，然后通过检查这个selector，就可以批量检测出数据可读的连接，进而读取数据。
	
NIO的优势：
	NIO模型中的线程数量大大降低，线程切换效率也大幅提高。
	IO读写是以字节块为单位，
	